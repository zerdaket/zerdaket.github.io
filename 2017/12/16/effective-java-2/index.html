<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="zerdaket, zerdaket@gmail.com"><title>Effective Java 2 —— 避免 Android 中的内存泄漏 · Zerdaket's Blog</title><meta name="description" content="前言
作为 Android 开发者，内存泄漏是我们无法忽视的问题。但在实际开发过程中，内存泄漏又是很隐蔽的。如何定义内存泄漏，内存泄漏是怎么产生的，该如何避免内存泄漏，这些将是本文讨论的重点。
何为内存泄漏
关于内存泄漏，我是这样理解的：

无用对象因被其他正在使用的实例持有引用，导致其占用的内存无"><meta name="keywords" content="Hexo, Android, Life"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Zerdaket's Blog</a></h3><div class="description"><p>“这个家伙很勤奋，但还是什么个性签名都没留下。”</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/zerdaket"><i class="fa fa-weibo"></i></a></li><li><a href="https://github.com/zerdaket"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Effective Java 2 —— 避免 Android 中的内存泄漏</a></h3></div><div class="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>作为 Android 开发者，内存泄漏是我们无法忽视的问题。但在实际开发过程中，内存泄漏又是很隐蔽的。如何定义内存泄漏，内存泄漏是怎么产生的，该如何避免内存泄漏，这些将是本文讨论的重点。</p>
<h2 id="何为内存泄漏"><a href="#何为内存泄漏" class="headerlink" title="何为内存泄漏"></a>何为内存泄漏</h2><hr>
<p>关于内存泄漏，我是这样理解的：</p>
<blockquote>
<p>无用对象因被其他正在使用的实例持有引用，导致其占用的内存无法正常地被回收。</p>
</blockquote>
<p>即使知道内存泄漏的存在，我们可能还是会不自觉地写出导致内存泄漏的代码（更恰当的表述应该是“无意识的对象保持”）。<br>如果发生了内存泄漏，无用对象占用的内存无法释放，应用可用内存减少，性能下降，更严重的时候可能还会触发 <code>内存溢出错误(Out Of Memory Error)</code> 。</p>
<h2 id="内存泄漏是如何产生的"><a href="#内存泄漏是如何产生的" class="headerlink" title="内存泄漏是如何产生的"></a>内存泄漏是如何产生的</h2><hr>
<p>在了解内存泄漏产生的原因之前，还需通过一些概念来帮助理解：</p>
<h3 id="Java-内存区域划分"><a href="#Java-内存区域划分" class="headerlink" title="Java 内存区域划分"></a>Java 内存区域划分</h3><p>我们知道一般的 Java 程序运行在 Java 虚拟机 (JVM) 中，JVM 的内存区域主要分为五个部分：</p>
<ul>
<li>程序计数器：控制代码流程，记录当前线程执行的位置。</li>
<li>Java 虚拟机栈：存放局部变量表、操作数栈、动态链接、方法出口信息。</li>
<li>本地方法栈：与 Java 虚拟机栈实现的功能类似，只不过存放的是本地方法的信息。</li>
<li>堆：存放对象的内存空间，程序运行时这部分内存由 JVM 管理分配。</li>
<li>方法区：存放常量、静态变量、类信息等。</li>
</ul>
<p>介绍完 Java 的内存区域划分，我们再通过 Java 对象的创建过程进行总结。</p>
<h3 id="Java-对象的创建和使用"><a href="#Java-对象的创建和使用" class="headerlink" title="Java 对象的创建和使用"></a>Java 对象的创建和使用</h3><p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> WHEEL_COUNT;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;&#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	Car sportsCar = <span class="keyword">new</span> Car();</div><div class="line">	sportsCar.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码中声明了一个 Car 类型的变量 <code>sportsCar</code> 存放在虚拟机栈中。在通过 <code>new</code> 指令创建一个 Car 对象之前，JVM 会先检查内存中是否加载了 Car.class ，如果没加载，则会将 Car.class 加载到方法区中，保存类的信息、<code>static</code> 关键字修饰的实例对象和 <code>final</code> 关键字修饰的实例对象等。然后在堆中开辟一块内存区域用于保存 <code>new Car()</code> 这个对象，并将一个指向它的强引用存储在 <code>sportsCar</code> 中。当执行 <code>sportsCar.start()</code> 方法时，实际上是 <code>sportsCar</code> 通过引用操控原对象调用的。</p>
<h3 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h3><p>Java 作为一种具有垃圾回收功能 (Garbage Collection，GC) 的语言，开发者不需要调用函数来释放内存，内存的回收都由 GC 来完成。虽然 Android 使用的 Dalvik/ART 虚拟机与一般的 JVM 不同，但 GC 策略还是通过标记清理（Mark &amp; Sweep）回收算法实现：</p>
<img src="/2017/12/16/effective-java-2/how_gc_works.png" alt="how gc works" title="how gc works">
<ul>
<li>Mark 阶段：<br>从根节点集合开始遍历，将可强引用到达根节点的对象被标记为存活。</li>
<li>Sweep 阶段：<br>回收那些没有被标记存活的对象所占用的内存。</li>
</ul>
<p><strong>其中，可以作为根节点的包括但不限于：① 栈（虚拟机栈/本地方法栈）中局部变量引用的对象；② 方法区中类静态变量引用的对象；③ 方法区中常量引用的对象； ④ 运行中的线程。</strong></p>
<p>此时，当一个对象已经不再需要但仍被持有引用，导致所占用的资源无法被 GC 回收，这样的情况下内存泄漏就产生了。</p>
<h2 id="解决内存泄漏的方法"><a href="#解决内存泄漏的方法" class="headerlink" title="解决内存泄漏的方法"></a>解决内存泄漏的方法</h2><hr>
<p>导致内存泄漏的根本原因：<br>一个变量或常量持有一个对象的强引用，且其生命周期比对象的长，致使对象占用的内存无法回收。</p>
<p>解决方法：</p>
<ul>
<li>手动解除强引用；</li>
<li>使用弱引用或软引用代替强引用。</li>
</ul>
<p>这里有必要提一下 Java 中的四种引用类型：</p>
<ul>
<li>强引用：默认引用类型，比如之前的例子 <code>Car sportsCar = new Car();</code> 就是变量 sportsCar 持有一个 Car 类型对象的强引用。在 GC 时，如果对象存在强引用就不能被回收；</li>
<li>软引用：在 GC 时，如果对象只存在软引用，只在内存不足的情况下该对象才会被回收；</li>
<li>弱引用：在 GC 时，如果对象只存在弱引用，该对象会被回收；</li>
<li>虚引用：只存在虚引用的对象可能会在任何时候被 GC 回收。</li>
</ul>
<p>因此使用弱引用或软引用可以有效地解决内存泄漏问题。</p>
<h2 id="具体案例分析"><a href="#具体案例分析" class="headerlink" title="具体案例分析"></a>具体案例分析</h2><hr>
<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>当应用程序启动时，系统会创建进程加载虚拟机。如果一个类被使用，虚拟机就会加载该类，这个类的静态变量等信息也将被分配到内存。一般在进程结束后类被卸载的情况下，静态变量占用的内存才能得到释放。所以静态变量的生命周期相当于整个应用程序的生命周期。<br>举一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreferencesHelper</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SharedPreferences sSharedPreferences;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> PreferencesHelper sInstance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PreferencesHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        sSharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PreferencesHelper <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (PreferencesHelper.class) &#123;</div><div class="line">                <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">                    sInstance = <span class="keyword">new</span> PreferencesHelper(context);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sInstance;</div><div class="line">    &#125;</div><div class="line">	</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PreferencesHelper 是一个单例模式的工具类，方便调用系统的 <code>SharedPreferences</code> 。当我们传入 Activity 的 <code>Context</code> 作为参数时，PreferencesHelper 的实例将会一直持有 Activity 的强引用直到进程结束。如果此时屏幕旋转，当前 Activity 需要被销毁重建，但是又被静态变量持有强引用而无法被销毁。</p>
<p>解决的方法很简单，使用 Application 的 <code>Context</code> 作为参数传入就可以了，因为 Application 的生命周期等同于应用程序的生命周期。PreferencesHelper 的实例持有 Application 的强引用，也不需要每次调用时传入其他 Activity 的 <code>Context</code> 了。</p>
<h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h3><p>Java 中的非静态内部类会隐式持有外部类实例的强引用，如果使用不当则非常容易导致内存泄漏。例如在使用 Handler 的时候，继承 Handler 实现一个 SimpleHandler 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> SimpleHandler mHandler = <span class="keyword">new</span> SimpleHandler();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_simple);</div><div class="line">        mHandler.obtainMessage().sendToTarget();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            	...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 SimpleHandler 就属于 SimpleActivity 的非静态内部类，SimpleHandler 的实例 <code>mHandler</code> 隐式持有外部类对象 <code>this</code> 的强引用。<br>在 Android 消息处理机制中，Looper 、MessageQueue 和 Handler 是不可或缺的三部分：</p>
<img src="/2017/12/16/effective-java-2/handler_1.png" alt="handler" title="handler">
<p>Looper 在主线程启动时初始化，并在内部创建一个消息队列 MessageQueue 来存放消息，Looper 会不断地从 MessageQueue 中取出消息，如果队列中没消息便阻塞。Handler 负责发送消息，并将消息插入消息队列中，每条消息除了可能有 Message 和 Runnable 外，还包含了 Handler 实例对象的强引用。Looper 在取出消息后会通过这个 Handler 实例对象的引用调用 <code>dispatchMessage(Message msg)</code> 方法将消息处理掉。</p>
<p>当 Activity 生命周期结束时，仍然存在持有该 Activity 强引用的 Message 于消息队列中没被消费，Activity 的实例对象便不能被销毁。</p>
<p>解决的方法很简单，使用静态内部类 + 弱引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> SimpleHandler mHandler = <span class="keyword">new</span> SimpleHandler(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_simple);</div><div class="line">        mHandler.obtainMessage().sendToTarget();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;SimpleActivity&gt; mReference;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SimpleHandler</span><span class="params">(SimpleActivity activity)</span> </span>&#123;</div><div class="line">            mReference = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">				...	</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将 Handler 设为静态内部类后不会隐式持有外部类的强引用，传入弱引用后也不会妨碍 GC 将 Activity 对象占用的内存回收。</p>
<p>有时候我们还会写出这样的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            	...</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>上面的 <code>mHandler</code> 是一个匿名内部类的实例，也属于非静态内部类的一种。实现匿名内部类时应当注意，在其生命周期结束时，是否存在其他变量持有匿名内部类对象的强引用，阻止 GC 回收。</p>
<h3 id="异步线程"><a href="#异步线程" class="headerlink" title="异步线程"></a>异步线程</h3><p>在执行一些耗时操作时，我们通常会开启一个线程去处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Thread mThread;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_simple);</div><div class="line">        mThread = <span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">super</span>.run();</div><div class="line">                <span class="keyword">while</span> (循环条件) &#123;</div><div class="line">			...</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        mThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>mThread</code> 其实也属于 SimpleActivity 的匿名内部类，持有外部类的强引用。当 Activity 销毁时线程仍未结束就会产生内存泄漏，所以需要手动管理线程的生命周期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Thread mThread;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_simple);</div><div class="line">        mThread = <span class="keyword">new</span> Thread() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">super</span>.run();</div><div class="line">                <span class="keyword">while</span> (循环条件 &amp;&amp; !isInterrupted()) &#123;</div><div class="line">			...</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        mThread.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line">        <span class="keyword">if</span> (mThread != <span class="keyword">null</span>) &#123;</div><div class="line">            mThread.interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同理，使用 Runnable 处理循环操作时也要注意在 Activity 销毁时及时中断线程。</p>
<p>在 Android 中，系统还提供了 AsyncTask 类方便使用者轻松地异步处理数据并更新到 UI 界面上。不过 AsyncTask 并不会随着 Activity 的销毁而销毁，它会一直执行 <code>doInBackground()</code> 方法直到方法执行结束。好在 AsyncTask 还提供了一个 <code>cancel(boolean mayInterruptIfRunning)</code> 方法取消提交的任务，只是这方法并非在任何情况下都起作用：<br><code>cancel()</code> 方法传入一个 boolean 类型的参数，意为“是否可以打断正在执行的任务”。<br>如果调用的是 <code>cancel(false)</code> ，<code>doInBackground()</code> 的执行不受影响，只不过任务结束时调用的是 <code>onCancelled()</code> 方法而不是 <code>onPostExecute()</code> 方法。这显然不是我们想要的结果，Activity 销毁时 AsyncTask 仍然在执行无用的操作。<br>如果调用的是 <code>cancel(true)</code> ，我们还需要做一些处理确保 AsyncTask 正确地被取消：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AsyncTask&lt;String, Void, Void&gt; mTask;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_simple);</div><div class="line">        mTask = <span class="keyword">new</span> AsyncTask&lt;String, Void, Void&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(String... strings)</span> </span>&#123;</div><div class="line">                <span class="keyword">while</span> (循环条件 &amp;&amp; !isCancelled()) &#123;</div><div class="line">                    ...</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        mTask.execute(<span class="string">"do something"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line">        <span class="keyword">if</span> (mTask != <span class="keyword">null</span>) &#123;</div><div class="line">            mTask.cancel(<span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>doInBackground()</code> 的循环方法中使用 <code>isCancelled()</code> 判断，如果 <code>mTask</code> 调用的是 <code>cancel(true)</code> 则可以使任务尽早结束。</p>
<h3 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h3><p>使用属性动画不当而导致内存泄漏的原因和异步线程一样。在 Activity / View 生命周期结束时，如果动画还在执行也会使其一直持有强引用直到动画结束，特别是在执行循环动画的情况下，Activity / View 的对象将无法得到释放。因此我们需要在 Activity / View 销毁时取消动画的执行。</p>
<p>在 Activity 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> ValueAnimator mAnimator;</div><div class="line"></div><div class="line">	...	</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line">        <span class="keyword">if</span> (mAnimator != <span class="keyword">null</span>) &#123;</div><div class="line">            mAnimator.cancel();</div><div class="line">            mAnimator = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在自定义 View 中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> ValueAnimator mAnimator;</div><div class="line"></div><div class="line">	...	</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDetachedFromWindow</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDetachedFromWindow();</div><div class="line">        <span class="keyword">if</span> (mAnimator != <span class="keyword">null</span>) &#123;</div><div class="line">            mAnimator.cancel();</div><div class="line">            mAnimator = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h3><p>为了更新 UI 界面，我们通常会实现一个 Listener 方便监听数据变化从而实时刷新界面，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">DownloadUtils</span>.<span class="title">DownloadListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_simple);</div><div class="line">        DownloadUtils.getInstance().setListener(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(String id)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">(String id)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(String id)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFail</span><span class="params">(String id, <span class="keyword">int</span> errorCode)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>DownloadUtils 是一个下载工具类，使用单例模式实现，其作用是下载文件并通过监听器通知界面更新 UI 。SimpleActivity 实现了 DownloadUtils.DownloadListener 接口，DownloadUtils 的实例对象通过调用 <code>setListener(DownloadListener listener)</code> 方法持有 Activity 的强引用。如果此时退出 Activity 或者屏幕旋转，SimpleActivity 的实例对象依然无法被回收。</p>
<p>解决办法便是为 DownloadUtils 添加一个 <code>removeListener(DownloadListener listener)</code> 方法，在 Activity 销毁之前解除引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onStop();</div><div class="line">        DownloadUtils.getInstance().removeListener(<span class="keyword">this</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>在使用 Collection 和 Map 这两大类集合的时候要注意，特别是在其生命周期较长的情况下（例如：某工具类里使用 List 类型的实例作为成员变量）。如果通过 <code>add()</code> 等方法持有外部类对象的强引用，在外部类对象销毁时又没有及时清除，集合内还维护着这些对象的过期引用。解决方法也很简单，一旦外部类对象的生命周期结束，调用集合的 <code>remove()</code> 等方法清除这些强引用。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><hr>
<p>在很多情况下，发生内存泄漏的原因都是持有强引用变量的生命周期大于原对象的生命周期，致使本该被销毁的对象不能被 GC 回收。但我们也不必刻意去清空每个变量的引用，清空对象引用应该是一直例外，而不是规范行为。对于生命周期长的实例对象，只需要注意其是否持有其他生命周期较短对象的强引用，在对象生命周期结束时清除即可。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><hr>
<ul>
<li><a href="http://www.jianshu.com/p/a9ff882337d4" target="_blank" rel="external">Java内存分配与回收机制</a></li>
<li><a href="http://allenfeng.com/2016/12/07/understanding-how-references-work-in-android-and-java/" target="_blank" rel="external">理解Android中的引用类型</a></li>
<li><a href="https://segmentfault.com/a/1190000004866028" target="_blank" rel="external">Android Handler的原理</a></li>
<li><a href="http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/" target="_blank" rel="external">译文：Android中糟糕的AsyncTask</a></li>
<li><a href="http://drakeet.me/android-leaks/" target="_blank" rel="external">Android 内存泄漏案例和解析</a> </li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-12-16</span><i class="fa fa-tag"></i><a href="/tags/Java/" title="Java" class="tag">Java </a><a href="/tags/Android/" title="Android" class="tag">Android </a></div></div></div></div><div class="share"><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey='].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,https://zerdaket.github.io/2017/12/16/effective-java-2/,Zerdaket's Blog,Effective Java 2 —— 避免 Android 中的内存泄漏,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2017/11/21/effective-java-1/" title="Effective Java 1 —— 静态工厂在 Android 中的应用" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>